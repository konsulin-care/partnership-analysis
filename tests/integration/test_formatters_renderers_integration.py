"""
Integration tests for formatters and renderers module interaction.

Specifically tests that CarboneRenderer can successfully consume JSON payloads
generated by the carbone_json_builder formatter.
"""

import json
import os
import tempfile
import pytest
from pathlib import Path
from unittest.mock import Mock, patch

# Import formatters
from src.python.formatters import generate_carbone_json

# Import renderers
from src.python.renderers import CarboneRenderer, PayloadValidator

# Import config
from src.python.config import ConfigLoader


@pytest.fixture
def sample_normalized_data():
    """Load and return sample normalized data for testing."""
    fixture_path = Path(__file__).parent.parent / "fixtures" / "sample_normalization_data.json"
    with open(fixture_path, 'r') as f:
        raw_data = json.load(f)

    # Transform raw data into normalized structure
    normalized_data = {
        'metadata': {
            'document_id': raw_data['raw_metadata']['doc_id'],
            'generated_at': raw_data['raw_metadata']['timestamp'],
            'schema_version': '1.0'
        },
        'organizations': [
            {
                'name': 'Test Hub Operator',
                'role': 'hub_operator',
                'location': {
                    'city': raw_data['raw_organization']['city'],
                    'country': raw_data['raw_organization']['country']
                },
                'contact': {
                    'email': 'hub@test.com'
                }
            },
            {
                'name': raw_data['raw_organization']['clinic_name'],
                'role': 'tenant',
                'location': {
                    'city': raw_data['raw_organization']['city'],
                    'country': raw_data['raw_organization']['country']
                },
                'contact': {
                    'email': raw_data['raw_organization']['email']
                }
            }
        ],
        'partnership_terms': {
            'revenue_share_pct': float(raw_data['raw_partnership_terms']['share_percentage']),
            'capex_investment_idr': int(raw_data['raw_partnership_terms']['capex']),
            'capex_hub_contribution_idr': int(raw_data['raw_partnership_terms']['hub_capex'].replace('.', '')),
            'space_sqm': float(raw_data['raw_partnership_terms']['area']),
            'commitment_years': int(raw_data['raw_partnership_terms']['years']),
            'launch_timeline_days': int(raw_data['raw_partnership_terms']['timeline'])
        },
        'financial_data': {
            'scenarios': [
                {
                    'name': 'standalone',
                    'breakeven_months': int(raw_data['raw_financial_scenario']['breakeven']),
                    'monthly_costs': {
                        'rent_idr': int(raw_data['raw_financial_scenario']['costs']['monthly_rent']),
                        'staff_idr': int(str(raw_data['raw_financial_scenario']['costs']['staff_cost']).replace(',', '')),
                        'utilities_idr': int(raw_data['raw_financial_scenario']['costs']['utility_cost']),
                        'medical_supplies_idr': int(str(raw_data['raw_financial_scenario']['costs']['supplies']).replace(',', '')),
                        'capex_amortization_idr': int(str(raw_data['raw_financial_scenario']['costs']['amortization']).replace(' ', ''))
                    },
                    'annual_profit_idr': int(str(raw_data['raw_financial_scenario']['annual_profit']).replace(',', ''))
                }
            ],
            'year_1_revenue_idr': 3420000000,
            'year_3_cumulative_savings_idr': 500000000,
            'npv_discount_rate': 0.12
        },
        'research_data': {
            'market_benchmarks': [
                {
                    'category': 'hair_transplant_pricing',
                    'value': 30000000,
                    'unit': 'idr',
                    'source_citation': 'Medical Aesthetics Market Report 2025',
                    'research_date': '2025-01-15',
                    'confidence': 0.85
                }
            ]
        },
        'quality_flags': {
            'missing_data_fields': [],
            'low_confidence_entities': [],
            'data_inconsistencies': []
        }
    }

    return normalized_data


@pytest.fixture
def config():
    """Create ConfigLoader instance for testing."""
    config_loader = ConfigLoader()
    return config_loader


@pytest.fixture
def temp_output_dir():
    """Create temporary directory for output files."""
    with tempfile.TemporaryDirectory() as temp_dir:
        yield temp_dir


@pytest.fixture
def mock_carbone_sdk():
    """Mock CarboneSDK class."""
    mock_sdk = Mock()
    mock_sdk.return_value = mock_sdk  # Constructor returns instance
    mock_sdk.render.return_value = b'%PDF-1.4\n1 0 obj\n<<\n/Type /Catalog\n/Pages 2 0 R\n>>\nendobj\nendobj\n%%EOF'
    return mock_sdk


class TestFormattersRenderersIntegration:
    """Integration tests for formatters and renderers interaction."""

    def test_carbone_json_builder_to_renderer_integration(self, sample_normalized_data, config, temp_output_dir, mock_carbone_sdk):
        """Test that carbone_json_builder output can be consumed by CarboneRenderer."""
        # Mock config
        config.get = Mock(side_effect=lambda key, default=None: {
            'output_dir': temp_output_dir,
            'carbone_api_key': 'test_api_key_123',
            'carbone_template_id': 'test_template_v1',
            'report_language': 'en',
            'pdf_margin_top': 20,
            'pdf_margin_bottom': 20,
            'pdf_margin_left': 15,
            'pdf_margin_right': 15
        }.get(key, default))

        with patch('src.python.renderers.carbone_renderer.CarboneSDK', mock_carbone_sdk):
            # Step 1: Generate Carbone JSON payload using formatters
            carbone_payload = generate_carbone_json(sample_normalized_data, config)

            # Verify payload structure
            assert isinstance(carbone_payload, dict)
            assert 'data' in carbone_payload
            assert 'template' in carbone_payload
            assert 'options' in carbone_payload

            # Step 2: Initialize renderer and validate payload
            renderer = CarboneRenderer(config)
            validator = PayloadValidator(config)

            is_valid, errors = validator.validate_payload(carbone_payload)
            assert is_valid, f"Payload validation failed: {errors}"

            # Step 3: Attempt rendering (should succeed with mocked SDK)
            output_path = os.path.join(temp_output_dir, 'integration_test.pdf')
            saved_path = renderer.render_and_save(carbone_payload['data'], output_path)

            # Verify PDF was created
            assert saved_path is not None
            assert os.path.exists(saved_path)
            assert saved_path.endswith('integration_test.pdf')

            # Verify PDF integrity
            is_valid_pdf, error_msg = renderer.validate_pdf_integrity(saved_path)
            assert is_valid_pdf, f"PDF validation failed: {error_msg}"

    def test_payload_structure_compatibility(self, sample_normalized_data, config):
        """Test that the JSON structure from carbone_json_builder matches renderer expectations."""
        config.get = Mock(side_effect=lambda key, default=None: {
            'carbone_template_id': 'test_template_v1',
            'report_language': 'en'
        }.get(key, default))

        # Generate payload
        carbone_payload = generate_carbone_json(sample_normalized_data, config)

        # Check required top-level keys
        assert 'data' in carbone_payload
        assert 'template' in carbone_payload
        assert 'options' in carbone_payload

        # Check data section has required document structure
        assert 'document' in carbone_payload['data']
        assert 'title' in carbone_payload['data']['document']

        # Check template section
        assert carbone_payload['template'] == 'test_template_v1'

        # Check options section
        assert 'language' in carbone_payload['options']
        assert carbone_payload['options']['language'] == 'en'

    def test_end_to_end_workflow_from_normalized_data(self, sample_normalized_data, config, temp_output_dir, mock_carbone_sdk):
        """Test complete workflow: normalized data -> Carbone JSON -> PDF rendering."""
        config.get = Mock(side_effect=lambda key, default=None: {
            'output_dir': temp_output_dir,
            'carbone_api_key': 'test_api_key_123',
            'carbone_template_id': 'test_template_v1',
            'report_language': 'en'
        }.get(key, default))

        with patch('src.python.renderers.carbone_renderer.CarboneSDK', mock_carbone_sdk):
            # Full pipeline: normalized data -> format -> render
            carbone_payload = generate_carbone_json(sample_normalized_data, config)
            renderer = CarboneRenderer(config)

            output_path = os.path.join(temp_output_dir, 'end_to_end_test.pdf')
            saved_path = renderer.render_and_save(carbone_payload['data'], output_path)

            assert os.path.exists(saved_path)

            # Verify the PDF contains expected content (mock returns fixed content)
            with open(saved_path, 'rb') as f:
                pdf_content = f.read()
            assert b'%PDF-1.4' in pdf_content
            assert b'%%EOF' in pdf_content

    def test_error_handling_in_integration(self, sample_normalized_data, config, temp_output_dir, mock_carbone_sdk):
        """Test error handling when formatters-renderers integration fails."""
        config.get = Mock(side_effect=lambda key, default=None: {
            'output_dir': temp_output_dir,
            'carbone_api_key': 'test_api_key_123',
            'carbone_template_id': 'test_template_v1'
        }.get(key, default))

        # Mock SDK to fail
        mock_client = Mock()
        mock_client.render.side_effect = RuntimeError("Rendering failed")
        mock_carbone_sdk.return_value = mock_client

        with patch('src.python.renderers.carbone_renderer.CarboneSDK', mock_carbone_sdk):
            carbone_payload = generate_carbone_json(sample_normalized_data, config)
            renderer = CarboneRenderer(config)

            output_path = os.path.join(temp_output_dir, 'error_test.pdf')

            # Should raise error since no error handler is used here
            with pytest.raises(RuntimeError, match="Rendering failed"):
                renderer.render_and_save(carbone_payload['data'], output_path)